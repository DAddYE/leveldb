{"name":"Leveldb","tagline":"LevelDB for Ruby (embedded)","body":"# Leveldb\r\n\r\nLevelDB is a database library (C++, 350 kB) written at Google. It is an\r\nembedded database. LevelDB is a persistent ordered map.\r\n\r\n> LevelDB stores keys and values in arbitrary byte arrays, and data is sorted by\r\n> key. It supports batching writes, forward and backward iteration, and\r\n> compression of the data via Google's Snappy compression library.  Still,\r\n> LevelDB is not a SQL database. (Wikipedia)\r\n\r\n## Features\r\n\r\n* Keys and values are arbitrary byte arrays.\r\n* Data is stored **sorted** by key.\r\n* Callers can provide a (_soon_) **custom comparison** function to override the sort order.\r\n* The basic operations are Put(key,value), Get(key), Delete(key).\r\n* Multiple changes can be made in one **atomic batch**.\r\n* Users can create a **transient snapshot** to get a consistent view of data.\r\n* _Forward_ and _backward_ iteration is supported over the data.\r\n* Data is automatically **compressed** using the **Snappy** compression library.\r\n* External activity (file system operations etc.) is relayed through a virtual\r\n  interface so users can customize the operating system interactions.\r\n* Detailed documentation about how to use the library is included\r\n  with the [source code](http://code.google.com/p/leveldb/).\r\n\r\n## Reading\r\n\r\n* [LevelDB](http://code.google.com/p/leveldb/)\r\n* [Great Reading](http://skipperkongen.dk/2013/02/14/having-a-look-at-leveldb/)\r\n* [Website](http://daddye.it/leveldb)\r\n\r\n## Installation\r\n\r\n### Development\r\n\r\n    $ brew install snappy\r\n    $ git clone git://github.com/DAddYE/leveldb.git\r\n    $ cd leveldb\r\n    $ rake compile\r\n    $ rake console\r\n\r\n### Standard\r\n\r\n    $ brew install snappy\r\n    $ gem install leveldb\r\n    $ irb -r leveldb\r\n\r\n## Usage\r\n\r\nHere a basic usage:\r\n\r\n```rb\r\ndb = LevelDB::DB.new '/tmp/foo'\r\n\r\n# Writing\r\ndb.put('hello', 'world')\r\ndb['hello'] = 'world'\r\n\r\n# Reading\r\ndb.get('hello') # => world\r\ndb['hello'] # => world\r\n\r\n# Deleting\r\ndb.delete('hello')\r\n\r\n# Iterating\r\ndb.each { |key, val| puts \"Key: #{key}, Val: #{val}\" }\r\ndb.reverse_each { |key, val| puts \"Key: #{key}, Val: #{val}\" }\r\ndb.keys\r\ndb.values\r\ndb.map { |k,v| do_some_with(k, v) }\r\ndb.reduce([]) { |memo, (k, v)| memo << k + v; memo }\r\ndb.each # => enumerator\r\ndb.reverse_each # => enumerator\r\n\r\n# Ranges\r\ndb.range('c', 'd') { |k,v| do_some_with_only_keys_in_range }\r\ndb.reverse_range('c', 'd') # => same as above but results are in reverse order\r\ndb.range(...) # => enumerable\r\n\r\n# Batches\r\ndb.batch do |b|\r\n  b.put 'a', 1\r\n  b.put 'b', 2\r\n  b.delete 'c'\r\nend\r\n\r\nb = db.batch\r\nb.put 'a', 1\r\nb.put 'b', 2\r\nb.delete 'c'\r\nb.write!\r\n\r\n# Snapshots\r\ndb.put 'a', 1\r\ndb.put 'b', 2\r\ndb.put 'c', 3\r\n\r\nsnap = db.snapshot\r\n\r\ndb.delete 'a'\r\ndb.get 'a' # => nil\r\n\r\nsnap.set!\r\n\r\ndb.get('a') # => 1\r\n\r\nsnap.reset!\r\n\r\ndb.get('a') # => nil\r\n\r\nsnap.set!\r\n\r\ndb.get('a') # => 1\r\n\r\n# Properties\r\ndb.read_property('leveldb.stats')\r\n\r\n# Level  Files Size(MB) Time(sec) Read(MB) Write(MB)\r\n# --------------------------------------------------\r\n#   0        1        0         0        0         0\r\n#   1        1        0         0        0         0\r\n\r\n# same of:\r\ndb.stats\r\n```\r\n\r\n## Todo\r\n\r\n1. Add pluggable serializers\r\n2. Custom comparators\r\n\r\n## Contributing\r\n\r\n1. Fork it\r\n2. Create your feature branch (`git checkout -b my-new-feature`)\r\n3. Commit your changes (`git commit -am 'Add some feature'`)\r\n4. Push to the branch (`git push origin my-new-feature`)\r\n5. Create new Pull Request\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}